<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roller Tests - D&amp;D Dice Roller</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    h1 {
      color: #e94560;
      border-bottom: 2px solid #e94560;
      padding-bottom: 10px;
    }
    .test-suite {
      margin: 20px 0;
    }
    .test-suite h2 {
      color: #0f3460;
      background: #16213e;
      padding: 10px;
      border-radius: 4px;
      color: #eee;
    }
    .test {
      padding: 10px 15px;
      margin: 5px 0;
      border-radius: 4px;
      display: flex;
      flex-direction: column;
    }
    .test-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .test.pass {
      background: #1b4332;
      border-left: 4px solid #40916c;
    }
    .test.fail {
      background: #5c1a1a;
      border-left: 4px solid #e94560;
    }
    .test-name {
      font-weight: 500;
    }
    .test-status {
      font-weight: bold;
    }
    .test.pass .test-status {
      color: #40916c;
    }
    .test.fail .test-status {
      color: #e94560;
    }
    .error-details {
      font-size: 0.85em;
      color: #ff8a8a;
      margin-top: 5px;
      padding: 5px;
      background: rgba(0,0,0,0.2);
      border-radius: 3px;
      word-break: break-word;
    }
    .summary {
      margin-top: 30px;
      padding: 20px;
      border-radius: 8px;
      font-size: 1.2em;
      text-align: center;
    }
    .summary.all-pass {
      background: #1b4332;
      border: 2px solid #40916c;
    }
    .summary.has-fail {
      background: #5c1a1a;
      border: 2px solid #e94560;
    }
  </style>
</head>
<body>
  <h1>Roller Tests</h1>
  <div id="results"></div>
  <div id="summary"></div>

  <script type="module">
    import { executeRoll } from './roller.js';
    import { parse } from './parser.js';

    const results = [];

    function test(name, fn) {
      try {
        fn();
        results.push({ name, pass: true });
      } catch (e) {
        results.push({ name, pass: false, error: e.message });
      }
    }

    function expect(actual) {
      return {
        toBe(expected) {
          if (actual !== expected) {
            throw new Error(`Expected ${expected} but got ${actual}`);
          }
        },
        toBeGreaterThanOrEqual(expected) {
          if (actual < expected) {
            throw new Error(`Expected ${actual} to be >= ${expected}`);
          }
        },
        toBeLessThanOrEqual(expected) {
          if (actual > expected) {
            throw new Error(`Expected ${actual} to be <= ${expected}`);
          }
        },
        toBeTrue() {
          if (actual !== true) {
            throw new Error(`Expected true but got ${actual}`);
          }
        },
        toBeFalse() {
          if (actual !== false) {
            throw new Error(`Expected false but got ${actual}`);
          }
        },
        toHaveLength(expected) {
          if (actual.length !== expected) {
            throw new Error(`Expected length ${expected} but got ${actual.length}`);
          }
        },
        toBeDefined() {
          if (actual === undefined) {
            throw new Error('Expected value to be defined but got undefined');
          }
        },
        toMatch(regex) {
          if (!regex.test(actual)) {
            throw new Error(`Expected ${actual} to match ${regex}`);
          }
        }
      };
    }

    // Helper to create a simple dice AST
    function diceAST(count, sides, options = {}) {
      return {
        dice: [{
          count,
          sides,
          keep: options.keep || null,
          drop: options.drop || null,
          exploding: options.exploding || false,
          reroll: options.reroll !== undefined ? options.reroll : null
        }],
        modifier: options.modifier || 0
      };
    }

    // ============================================
    // Basic Roll Structure Tests
    // ============================================

    test('executeRoll returns RollResult with required properties', () => {
      const parsed = diceAST(1, 20);
      const result = executeRoll(parsed, '1d20');

      expect(result.id).toBeDefined();
      expect(result.timestamp).toBeDefined();
      expect(result.input).toBe('1d20');
      expect(result.parsed).toBeDefined();
      expect(result.rolls).toBeDefined();
      expect(result.subtotal).toBeDefined();
      expect(result.modifier).toBeDefined();
      expect(result.total).toBeDefined();
    });

    test('executeRoll generates valid UUID', () => {
      const parsed = diceAST(1, 20);
      const result = executeRoll(parsed);

      // UUID v4 format
      expect(result.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i);
    });

    test('executeRoll generates valid ISO timestamp', () => {
      const parsed = diceAST(1, 20);
      const result = executeRoll(parsed);

      // ISO 8601 format
      expect(result.timestamp).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/);
    });

    // ============================================
    // Basic Roll Tests
    // ============================================

    test('1d20 produces value between 1 and 20', () => {
      const parsed = diceAST(1, 20);

      // Run multiple times to test randomness
      for (let i = 0; i < 100; i++) {
        const result = executeRoll(parsed);
        expect(result.rolls).toHaveLength(1);
        expect(result.rolls[0].value).toBeGreaterThanOrEqual(1);
        expect(result.rolls[0].value).toBeLessThanOrEqual(20);
        expect(result.rolls[0].die).toBe('d20');
        expect(result.rolls[0].kept).toBeTrue();
      }
    });

    test('1d6 produces value between 1 and 6', () => {
      const parsed = diceAST(1, 6);

      for (let i = 0; i < 100; i++) {
        const result = executeRoll(parsed);
        expect(result.rolls[0].value).toBeGreaterThanOrEqual(1);
        expect(result.rolls[0].value).toBeLessThanOrEqual(6);
      }
    });

    test('3d6 produces 3 rolls, each between 1 and 6', () => {
      const parsed = diceAST(3, 6);

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);
        expect(result.rolls).toHaveLength(3);

        result.rolls.forEach(roll => {
          expect(roll.value).toBeGreaterThanOrEqual(1);
          expect(roll.value).toBeLessThanOrEqual(6);
          expect(roll.die).toBe('d6');
          expect(roll.kept).toBeTrue();
        });
      }
    });

    test('subtotal equals sum of all kept dice', () => {
      const parsed = diceAST(4, 6);

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);
        const expectedSubtotal = result.rolls
          .filter(r => r.kept)
          .reduce((sum, r) => sum + r.value, 0);
        expect(result.subtotal).toBe(expectedSubtotal);
      }
    });

    // ============================================
    // Keep Highest Tests
    // ============================================

    test('2d20kh1 keeps only the higher value', () => {
      const parsed = diceAST(2, 20, { keep: { type: 'highest', count: 1 } });

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);
        expect(result.rolls).toHaveLength(2);

        const keptRolls = result.rolls.filter(r => r.kept);
        const notKeptRolls = result.rolls.filter(r => !r.kept);

        expect(keptRolls).toHaveLength(1);
        expect(notKeptRolls).toHaveLength(1);

        // The kept roll should be >= the not kept roll
        expect(keptRolls[0].value).toBeGreaterThanOrEqual(notKeptRolls[0].value);

        // Subtotal should equal the kept die value
        expect(result.subtotal).toBe(keptRolls[0].value);
      }
    });

    test('4d6kh3 keeps highest 3 values', () => {
      const parsed = diceAST(4, 6, { keep: { type: 'highest', count: 3 } });

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);
        expect(result.rolls).toHaveLength(4);

        const keptRolls = result.rolls.filter(r => r.kept);
        const notKeptRolls = result.rolls.filter(r => !r.kept);

        expect(keptRolls).toHaveLength(3);
        expect(notKeptRolls).toHaveLength(1);

        // The not kept roll should be <= min of kept rolls
        const minKept = Math.min(...keptRolls.map(r => r.value));
        expect(notKeptRolls[0].value).toBeLessThanOrEqual(minKept);
      }
    });

    // ============================================
    // Keep Lowest Tests
    // ============================================

    test('2d20kl1 keeps only the lower value', () => {
      const parsed = diceAST(2, 20, { keep: { type: 'lowest', count: 1 } });

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);
        expect(result.rolls).toHaveLength(2);

        const keptRolls = result.rolls.filter(r => r.kept);
        const notKeptRolls = result.rolls.filter(r => !r.kept);

        expect(keptRolls).toHaveLength(1);
        expect(notKeptRolls).toHaveLength(1);

        // The kept roll should be <= the not kept roll
        expect(keptRolls[0].value).toBeLessThanOrEqual(notKeptRolls[0].value);
      }
    });

    // ============================================
    // Drop Lowest Tests
    // ============================================

    test('4d6dl1 drops only the lowest value', () => {
      const parsed = diceAST(4, 6, { drop: { type: 'lowest', count: 1 } });

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);
        expect(result.rolls).toHaveLength(4);

        const keptRolls = result.rolls.filter(r => r.kept);
        const droppedRolls = result.rolls.filter(r => r.dropped);

        expect(keptRolls).toHaveLength(3);
        expect(droppedRolls).toHaveLength(1);

        // The dropped roll should be <= min of kept rolls
        const minKept = Math.min(...keptRolls.map(r => r.value));
        expect(droppedRolls[0].value).toBeLessThanOrEqual(minKept);

        // dropped flag should be set
        expect(droppedRolls[0].dropped).toBeTrue();
      }
    });

    test('5d10dl2 drops lowest 2 values', () => {
      const parsed = diceAST(5, 10, { drop: { type: 'lowest', count: 2 } });

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);
        expect(result.rolls).toHaveLength(5);

        const keptRolls = result.rolls.filter(r => r.kept);
        const droppedRolls = result.rolls.filter(r => r.dropped);

        expect(keptRolls).toHaveLength(3);
        expect(droppedRolls).toHaveLength(2);
      }
    });

    // ============================================
    // Drop Highest Tests
    // ============================================

    test('4d6dh1 drops the highest value', () => {
      const parsed = diceAST(4, 6, { drop: { type: 'highest', count: 1 } });

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);
        expect(result.rolls).toHaveLength(4);

        const keptRolls = result.rolls.filter(r => r.kept);
        const droppedRolls = result.rolls.filter(r => r.dropped);

        expect(keptRolls).toHaveLength(3);
        expect(droppedRolls).toHaveLength(1);

        // The dropped roll should be >= max of kept rolls
        const maxKept = Math.max(...keptRolls.map(r => r.value));
        expect(droppedRolls[0].value).toBeGreaterThanOrEqual(maxKept);
      }
    });

    // ============================================
    // Modifier Tests
    // ============================================

    test('1d20+5 adds 5 to total', () => {
      const parsed = diceAST(1, 20, { modifier: 5 });

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);
        expect(result.modifier).toBe(5);
        expect(result.total).toBe(result.subtotal + 5);
        expect(result.total).toBeGreaterThanOrEqual(6);  // 1 + 5
        expect(result.total).toBeLessThanOrEqual(25);    // 20 + 5
      }
    });

    test('1d20-3 subtracts 3 from total', () => {
      const parsed = diceAST(1, 20, { modifier: -3 });

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);
        expect(result.modifier).toBe(-3);
        expect(result.total).toBe(result.subtotal - 3);
        expect(result.total).toBeGreaterThanOrEqual(-2);  // 1 - 3
        expect(result.total).toBeLessThanOrEqual(17);     // 20 - 3
      }
    });

    // ============================================
    // Combined Tests
    // ============================================

    test('4d6dl1+2 drops lowest, adds 2', () => {
      const parsed = diceAST(4, 6, {
        drop: { type: 'lowest', count: 1 },
        modifier: 2
      });

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);

        const keptRolls = result.rolls.filter(r => r.kept);
        const droppedRolls = result.rolls.filter(r => r.dropped);

        expect(keptRolls).toHaveLength(3);
        expect(droppedRolls).toHaveLength(1);

        const expectedSubtotal = keptRolls.reduce((sum, r) => sum + r.value, 0);
        expect(result.subtotal).toBe(expectedSubtotal);
        expect(result.modifier).toBe(2);
        expect(result.total).toBe(expectedSubtotal + 2);
      }
    });

    test('2d20kh1+5 keeps highest, adds 5', () => {
      const parsed = diceAST(2, 20, {
        keep: { type: 'highest', count: 1 },
        modifier: 5
      });

      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);

        const keptRolls = result.rolls.filter(r => r.kept);
        expect(keptRolls).toHaveLength(1);

        expect(result.modifier).toBe(5);
        expect(result.total).toBe(result.subtotal + 5);
      }
    });

    // ============================================
    // Exploding Dice Tests
    // ============================================

    test('exploding dice adds extra rolls on max value', () => {
      // Use a small die to increase chance of explosion
      const parsed = diceAST(10, 2, { exploding: true });

      let sawExplosion = false;
      for (let i = 0; i < 100; i++) {
        const result = executeRoll(parsed);

        // Check if any explosions occurred
        const explodedRolls = result.rolls.filter(r => r.exploded);
        if (explodedRolls.length > 0) {
          sawExplosion = true;
          // There should be more than 10 rolls if explosion occurred
          expect(result.rolls.length).toBeGreaterThanOrEqual(10);
        }
      }

      // With d2 rolled 10 times over 100 iterations, we should see explosions
      expect(sawExplosion).toBeTrue();
    });

    test('exploded rolls are marked with exploded flag', () => {
      const parsed = diceAST(20, 2, { exploding: true });

      let foundExploded = false;
      for (let i = 0; i < 50 && !foundExploded; i++) {
        const result = executeRoll(parsed);
        const explodedRolls = result.rolls.filter(r => r.exploded);
        if (explodedRolls.length > 0) {
          foundExploded = true;
          explodedRolls.forEach(roll => {
            expect(roll.exploded).toBeTrue();
            expect(roll.kept).toBeTrue();
          });
        }
      }
    });

    // ============================================
    // Reroll Tests
    // ============================================

    test('reroll marks original value and rerolls once', () => {
      // Roll many d6 with reroll 1
      const parsed = diceAST(20, 6, { reroll: 1 });

      let sawReroll = false;
      for (let i = 0; i < 50; i++) {
        const result = executeRoll(parsed);

        const rerolledDice = result.rolls.filter(r => r.rerolled);
        if (rerolledDice.length > 0) {
          sawReroll = true;
          rerolledDice.forEach(roll => {
            expect(roll.rerolled).toBeTrue();
            expect(roll.originalValue).toBe(1);
            // New value can be anything 1-6 (it's not rerolled again)
            expect(roll.value).toBeGreaterThanOrEqual(1);
            expect(roll.value).toBeLessThanOrEqual(6);
          });
        }
      }

      // With 20d6 rolled 50 times, we should have seen at least one 1
      expect(sawReroll).toBeTrue();
    });

    // ============================================
    // Integration Tests with Parser
    // ============================================

    test('integration: parse and execute 1d20', () => {
      const parsed = parse('1d20');
      const result = executeRoll(parsed, '1d20');

      expect(result.rolls).toHaveLength(1);
      expect(result.rolls[0].value).toBeGreaterThanOrEqual(1);
      expect(result.rolls[0].value).toBeLessThanOrEqual(20);
      expect(result.input).toBe('1d20');
    });

    test('integration: parse and execute 4d6dl1', () => {
      const parsed = parse('4d6dl1');
      const result = executeRoll(parsed, '4d6dl1');

      expect(result.rolls).toHaveLength(4);
      const keptRolls = result.rolls.filter(r => r.kept);
      expect(keptRolls).toHaveLength(3);
    });

    test('integration: parse and execute 2d20kh1+5', () => {
      const parsed = parse('2d20kh1+5');
      const result = executeRoll(parsed, '2d20kh1+5');

      expect(result.rolls).toHaveLength(2);
      const keptRolls = result.rolls.filter(r => r.kept);
      expect(keptRolls).toHaveLength(1);
      expect(result.modifier).toBe(5);
      expect(result.total).toBe(result.subtotal + 5);
    });

    // Render results
    const container = document.getElementById('results');
    const summary = document.getElementById('summary');

    let passCount = 0;
    let failCount = 0;

    results.forEach(result => {
      const div = document.createElement('div');
      div.className = `test ${result.pass ? 'pass' : 'fail'}`;

      const headerDiv = document.createElement('div');
      headerDiv.className = 'test-header';

      const nameSpan = document.createElement('span');
      nameSpan.className = 'test-name';
      nameSpan.textContent = result.name;

      const statusSpan = document.createElement('span');
      statusSpan.className = 'test-status';
      statusSpan.textContent = result.pass ? 'PASS' : 'FAIL';

      headerDiv.appendChild(nameSpan);
      headerDiv.appendChild(statusSpan);
      div.appendChild(headerDiv);

      if (!result.pass && result.error) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-details';
        errorDiv.textContent = result.error;
        div.appendChild(errorDiv);
      }

      container.appendChild(div);

      if (result.pass) {
        passCount++;
      } else {
        failCount++;
      }
    });

    summary.className = `summary ${failCount === 0 ? 'all-pass' : 'has-fail'}`;
    summary.textContent = `${passCount} passed, ${failCount} failed out of ${results.length} tests`;
  </script>
</body>
</html>
